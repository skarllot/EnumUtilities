<#@ template debug="false" linePragmas="false" hostspecific="false" language="C#" inherits="CodeWriterBase<EnumToGenerate>" #>
<#@ import namespace="Common" #>
<#@ import namespace="Models" #>
<#@ import namespace="System.Text" #>
<#
    if (Model.JsonConverterGeneratorOptions is null)
        return string.Empty;
#>
// <auto-generated />
#nullable enable

using System;
using System.Text.Json;
using System.Text.Json.Serialization;

#pragma warning disable CS1591 // publicly visible type or member must be documented

<#
    if (!string.IsNullOrEmpty(Model.Namespace))
    {
        WriteLine($"namespace {Model.Namespace}");
        WriteLine("{");
        PushIndent();
    }
#>
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[global::System.CodeDom.Compiler.GeneratedCodeAttribute("<#= CurrentAssemblyName.Name #>", "<#= Append($"{CurrentAssemblyName.Version}") #>")]
<#= Model.IsPublic ? "public" : "internal" #> sealed class <#= Model.Name #>JsonConverter : JsonConverter<<#= Model.Name #>>
{
    private const int MaxBytesLength = <#=
                    Model.Values.Max(
                        x => GetEncodedLength(x.JsonPropertyName ?? x.SerializationValue ?? x.MemberName)) #>;
    private const int MaxCharsLength = <#=
                    Model.Values.Max(
                        x => x.JsonPropertyName?.Length ?? x.SerializationValue?.Length ?? x.MemberName.Length) #>;

    public override <#= Model.Name #> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == JsonTokenType.String)
            return (<#= Model.RefName #>)ReadFromString(ref reader);
<#
    if (Model.JsonConverterGeneratorOptions.AllowIntegerValues)
    {
#>
        if (reader.TokenType == JsonTokenType.Number)
            return (<#= Model.RefName #>)ReadFromNumber(ref reader);
<#
    }
#>

        <#= AppendFallbackValue(addReturn: true) #>;
    }

    public override void Write(Utf8JsonWriter writer, <#= Model.Name #> value, JsonSerializerOptions options)
    {
        switch ((<#= Model.UnderlyingType #>)value)
        {
<#
    foreach (var curr in Model.UniqueValues)
    {
#>
            case <#= curr.MemberValue #>:
                writer.WriteStringValue("<#= curr.JsonPropertyName ?? curr.SerializationValue ?? curr.MemberName #>"u8);
                break;
<#
    }
#>
            default:
                writer.WriteStringValue(value.ToString());
                break;
        }
    }

    private <#= Model.UnderlyingType #> ReadFromString(ref Utf8JsonReader reader)
    {
#if NET7_0_OR_GREATER
        int length = reader.HasValueSequence ? checked((int)reader.ValueSequence.Length) : reader.ValueSpan.Length;
        if (length > MaxBytesLength)
            <#= AppendFallbackValue(addReturn: true) #>;

        Span<char> name = stackalloc char[MaxBytesLength];
        int charsWritten = reader.CopyString(name);
        name = name.Slice(0, charsWritten);
#else
        string? name = reader.GetString();
#endif

        return name switch
        {
<#
    foreach (var curr in Model.Values)
    {
#>
            <#=
                curr.JsonPropertyName is not null || curr.SerializationValue is not null
                    ? Append($"\"{curr.JsonPropertyName ?? curr.SerializationValue}\"")
                    : Append($"\"{curr.MemberName}\"") #> => <#= NeedNumberCasting() ? Append($"({Model.UnderlyingType})") : Append("") #><#= curr.MemberValue #>,
<#
    }
#>
            _ => Enum.TryParse(name, out <#= Model.RefName #> result) ? (<#= Model.UnderlyingType #>)result : <#= AppendFallbackValue() #>
        };
    }
<#
    if (Model.JsonConverterGeneratorOptions.AllowIntegerValues)
    {
#>

    private <#= Model.UnderlyingType #> ReadFromNumber(ref Utf8JsonReader reader)
    {
        return reader.TryGet<#= CSharpExtensions.GetTypeNameFromCSharpKeyword(Model.UnderlyingType) #>(out <#= Model.UnderlyingType #> value)
            ? value
            : <#= AppendFallbackValue() #>;
    }
<#
    }
#>
}
<#
    if (!string.IsNullOrEmpty(Model.Namespace))
    {
        PopIndent();
        WriteLine("}");
    }
#>
<#+
#nullable enable
    public EnumJsonConverterWriter(StringBuilder builder) : base(builder)
    {
    }

    public override string GetFileName() => $"{Model.Namespace ?? "_"}.{Model.Name}JsonConverter.g.cs";

    protected override bool CanGenerateFor(EnumToGenerate model) =>
        (model.SelectedGenerators & SelectedGenerators.JsonConverter) != 0;

    private None AppendFallbackValue(bool addReturn = false)
    {
        object? fallbackValue = Model.JsonConverterGeneratorOptions!.DeserializationFailureFallbackValue;
        return fallbackValue is not null
            ? Append(
                $"{(addReturn ? "return " : "")}{(NeedNumberCasting() ? $"({Model.UnderlyingType})" : "")}{fallbackValue}")
            : Append("throw new JsonException()");
    }

    private static int GetEncodedLength(string value) => value.Sum(c => c < 128 ? 1 : 6);
    private bool NeedNumberCasting() => Model.UnderlyingType is "byte" or "short" or "sbyte" or "ushort";
#>
