<#@ template debug="false" linePragmas="false" hostspecific="false" language="C#" inherits="CodeWriterBase<EnumToGenerate>" #>
<#@ import namespace="Common" #>
<#@ import namespace="Models" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="T4CodeWriter" #>
<#
    if (Model.JsonConverterGeneratorOptions is null)
        return string.Empty;
#>
// <auto-generated />
#nullable enable

using System;
using System.Buffers;
using System.Text.Json;
using System.Text.Json.Serialization;
using Raiqub.Generators.EnumUtilities.Formatters;
using Raiqub.Generators.EnumUtilities.Parsers;

#pragma warning disable CS1591 // publicly visible type or member must be documented

<#
    if (!string.IsNullOrEmpty(Model.Namespace))
    {
        WriteLine($"namespace {Model.Namespace}");
        WriteLine("{");
        PushIndent();
    }
#>
[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]
[global::System.CodeDom.Compiler.GeneratedCodeAttribute("<#= CurrentAssemblyName.Name #>", "<#= Append($"{CurrentAssemblyName.Version}") #>")]
<#= Model.IsPublic ? "public" : "internal" #> sealed partial class <#= Model.Name #>JsonConverter : JsonConverter<<#= Model.Name #>>
{
    private const int MaxCharStack = 256;

    public override <#= Model.RefName #> Read(ref Utf8JsonReader reader, Type typeToConvert, JsonSerializerOptions options)
    {
        if (reader.TokenType == JsonTokenType.String)
            return ReadFromString(ref reader);
<#
    if (Model.JsonConverterGeneratorOptions.AllowIntegerValues)
    {
#>
        if (reader.TokenType == JsonTokenType.Number)
            return (<#= Model.RefName #>)ReadFromNumber(ref reader);
<#
    }
#>

        <#= AppendFallbackValue(addReturn: true, castToEnum: true) #>;
    }

    public override void Write(Utf8JsonWriter writer, <#= Model.RefName #> value, JsonSerializerOptions options)
    {
        string? jsonString = value.ToJsonString();
        if (jsonString is not null)
        {
            writer.WriteStringValue(jsonString);
        }
<#
    if (Model.JsonConverterGeneratorOptions.AllowIntegerValues)
    {
#>
        else
        {
            writer.WriteNumberValue((<#= Model.UnderlyingType #>)value);
        }
<#
    }
    else if (Model.JsonConverterGeneratorOptions.DeserializationFailureFallbackValue is not null)
    {
#>
        else
        {
            jsonString = ((<#= Model.RefName #>)<#= Model.JsonConverterGeneratorOptions.DeserializationFailureFallbackValue #>).ToJsonString();
            if (jsonString is not null)
                writer.WriteStringValue(jsonString);
            else
                throw new JsonException();
        }
<#
    }
    else
    {
#>
        else
        {
            throw new JsonException();
        }
<#
    }
#>
    }

#if NET7_0_OR_GREATER

    private <#= Model.RefName #> ReadFromString(ref Utf8JsonReader reader)
    {
        int length = reader.HasValueSequence ? checked((int)reader.ValueSequence.Length) : reader.ValueSpan.Length;

        char[]? rented = null;
        Span<char> name = length <= MaxCharStack ? stackalloc char[MaxCharStack] : (rented = ArrayPool<char>.Shared.Rent(length));
        try
        {
            int charsWritten = reader.CopyString(name);
            name = name.Slice(0, charsWritten);

            bool isParsed = <#= Model.Name #>Factory.TryParseJsonString(name, ignoreCase: <#= Model.JsonConverterGeneratorOptions.IgnoreCase ? "true" : "false" #>, out <#= Model.RefName #> result);
            if (!isParsed)
            {
                <#= AppendFallbackValue(addReturn: true, castToEnum: true) #>;
            }

            return result;
        }
        finally
        {
            if (rented != null)
            {
                ArrayPool<char>.Shared.Return(rented);
            }
        }
    }

#else

    private <#= Model.RefName #> ReadFromString(ref Utf8JsonReader reader)
    {
        var name = reader.GetString();
        bool isParsed = <#= Model.Name #>Factory.TryParseJsonString(name, ignoreCase: <#= Model.JsonConverterGeneratorOptions.IgnoreCase ? "true" : "false" #>, out <#= Model.RefName #> result);
        if (!isParsed)
        {
            <#= AppendFallbackValue(addReturn: true, castToEnum: true) #>;
        }

        return result;
    }

#endif
<#
    if (Model.JsonConverterGeneratorOptions.AllowIntegerValues)
    {
#>

    private <#= Model.UnderlyingType #> ReadFromNumber(ref Utf8JsonReader reader)
    {
        return reader.TryGet<#= CSharpExtensions.GetTypeNameFromCSharpKeyword(Model.UnderlyingType) #>(out <#= Model.UnderlyingType #> value)
            ? value
            : <#= AppendFallbackValue() #>;
    }
<#
    }
#>
}
<#
    if (!string.IsNullOrEmpty(Model.Namespace))
    {
        PopIndent();
        WriteLine("}");
    }
#>
<#+
#nullable enable
    public EnumJsonConverterWriter(StringBuilder builder) : base(builder)
    {
    }

    public override string GetFileName() => $"{Model.Namespace ?? "_"}.{Model.Name}JsonConverter.g.cs";

    protected override bool CanGenerateFor(EnumToGenerate model) =>
        (model.SelectedGenerators & SelectedGenerators.JsonConverter) != 0;

    private None AppendFallbackValue(bool addReturn = false, bool castToEnum = false)
    {
        object? fallbackValue = Model.JsonConverterGeneratorOptions!.DeserializationFailureFallbackValue;
        if (fallbackValue is null)
            return Append("throw new JsonException()");

        if (addReturn)
            Append("return ");
        if (castToEnum)
            Append($"({Model.RefName})");
        if (!castToEnum && NeedNumberCasting())
            Append($"({Model.UnderlyingType})");

        return Append($"{fallbackValue}");
    }

    private bool NeedNumberCasting() => Model.UnderlyingType is "byte" or "short" or "sbyte" or "ushort";
#>
