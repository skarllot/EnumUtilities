// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 16.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Raiqub.Generators.EnumUtilities.CodeWriters
{
    using System;
    using System.Text;
    using Common;
    using Models;
    using T4CodeWriter;

    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public partial class EnumFactoryWriter : CodeWriterBase<EnumToGenerate>
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
#nullable enable

            this.Write(
                "// <auto-generated />\n#nullable enable\n\nusing System;\nusing System.Diagnostics.CodeAnalysis;\nusing System.Globalization;\nusing System.Runtime.CompilerServices;\nusing Raiqub.Generators.EnumUtilities.Parsers;\n\n#pragma warning disable CS1591 // publicly visible type or member must be documented\n\n"
            );

            if (!string.IsNullOrEmpty(Model.Namespace))
            {
                Write($"namespace {Model.Namespace};\n\n");
            }

            this.Write(
                "[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\""
            );
            this.Write((CurrentAssemblyName.Name));
            this.Write("\", \"");
            this.Write((Append($"{CurrentAssemblyName.Version}")));
            this.Write("\")]\n");
            this.Write((Model.IsPublic ? "public" : "internal"));
            this.Write(" static partial class ");
            this.Write((Model.Name));
            this.Write("Factory\n{\n");

            if ((Model.SelectedGenerators & SelectedGenerators.MainGenerator) != 0)
            {
                WriteDefaultBlock();
                WriteEnumMemberBlock();
                WriteDescriptionBlock();
                WriteDisplayBlock();
                WriteMiscellaneousBlock();
            }
            WriteJsonBlock();

            this.Write("}\n");
            return this.GenerationEnvironment.ToString();
        }

        private static string GetIgnoreCaseToComparisonExpression() =>
            "ignoreCase ? StringComparison.OrdinalIgnoreCase : StringComparison.Ordinal";

        private static string GetComparisonExpression(bool ignoreCase) =>
            ignoreCase ? "StringComparison.OrdinalIgnoreCase" : "StringComparison.Ordinal";

        private void WriteTryParse(
            Func<EnumValue, string?> keySelector,
            string type,
            string parameterName = "value",
            bool allowNumbers = true
        )
        {
            this.Write("    private static bool TryParse");
            this.Write((type));
            this.Write("(ReadOnlySpan<char> ");
            this.Write((parameterName));
            this.Write(", StringComparison comparisonType, bool throwOnFailure, out ");
            this.Write((Model.UnderlyingType));
            this.Write(" result)\n    {\n        if (!");
            this.Write((parameterName));
            this.Write(".IsEmpty)\n        {\n");

            if (allowNumbers)
            {
                this.Write("            char c = ");
                this.Write((parameterName));
                this.Write("[0];\n            if (char.IsWhiteSpace(c))\n            {\n                ");
                this.Write((parameterName));
                this.Write(" = ");
                this.Write((parameterName));
                this.Write(".TrimStart();\n                if (");
                this.Write((parameterName));
                this.Write(
                    ".IsEmpty)\n                {\n                    goto ParseFailure;\n                }\n\n                c = "
                );
                this.Write((parameterName));
                this.Write(
                    "[0];\n            }\n\n            if ((c < '0' || c > '9') && c != '-' && c != '+')\n            {\n                return TryParseNonNumeric"
                );
                this.Write((type));
                this.Write("(");
                this.Write((parameterName));
                this.Write(
                    ", comparisonType, throwOnFailure, out result);\n            }\n\n            bool success = EnumNumericParser.TryParse("
                );
                this.Write((parameterName));
                this.Write(
                    ", out result);\n            if (success)\n            {\n                return true;\n            }\n\n"
                );
            }

            this.Write("            return TryParseNonNumeric");
            this.Write((type));
            this.Write("(");
            this.Write((parameterName));
            this.Write(", comparisonType, throwOnFailure, out result);\n        }\n\n");

            if (allowNumbers)
            {
                this.Write("        ParseFailure:\n");
            }

            this.Write(
                "        if (throwOnFailure)\n        {\n            ThrowHelper.ThrowInvalidEmptyParseArgument(nameof("
            );
            this.Write((parameterName));
            this.Write("));\n        }\n\n        result = 0;\n        return false;\n    }\n");

            Write('\n');
            WriteTryParseNonNumeric(type, parameterName);
            Write('\n');
            WriteTryParseLookup(keySelector, type);
        }

        private void WriteTryParseNonNumeric(string type, string parameterName = "value")
        {
            if (Model.IsFlags)
            {
                this.Write("    private static bool TryParseNonNumeric");
                this.Write((type));
                this.Write("(ReadOnlySpan<char> ");
                this.Write((parameterName));
                this.Write(", StringComparison comparisonType, bool throwOnFailure, out ");
                this.Write((Model.UnderlyingType));
                this.Write(" result)\n    {\n        bool parsed = true;\n        ");
                this.Write((Model.UnderlyingType));
                this.Write(" localResult = 0;\n        foreach (var item in new FlagsEnumTokenizer(");
                this.Write((parameterName));
                this.Write("))\n        {\n            bool success = TryParseSingle");
                this.Write((type));
                this.Write("(item, comparisonType, out ");
                this.Write((Model.UnderlyingType));
                this.Write(
                    " singleValue);\n            if (!success)\n            {\n                parsed = false;\n                break;\n            }\n\n            localResult |= singleValue;\n        }\n\n        if (parsed)\n        {\n            result = localResult;\n            return true;\n        }\n\n        if (throwOnFailure)\n        {\n            ThrowHelper.ThrowValueNotFound("
                );
                this.Write((parameterName));
                this.Write(", nameof(");
                this.Write((parameterName));
                this.Write("));\n        }\n\n        result = 0;\n        return false;\n    }\n");
            }
            else
            {
                this.Write("    private static bool TryParseNonNumeric");
                this.Write((type));
                this.Write("(ReadOnlySpan<char> ");
                this.Write((parameterName));
                this.Write(", StringComparison comparisonType, bool throwOnFailure, out ");
                this.Write((Model.UnderlyingType));
                this.Write(" result)\n    {\n        bool success = TryParseSingle");
                this.Write((type));
                this.Write("(");
                this.Write((parameterName));
                this.Write(
                    ", comparisonType, out result);\n        if (success)\n        {\n            return true;\n        }\n\n        if (throwOnFailure)\n        {\n            ThrowHelper.ThrowValueNotFound("
                );
                this.Write((parameterName));
                this.Write(", nameof(");
                this.Write((parameterName));
                this.Write("));\n        }\n\n        return false;\n    }\n");
            }
        }

        private void WriteTryParseLookup(Func<EnumValue, string?> keySelector, string type)
        {
            this.Write("    private static bool TryParseSingle");
            this.Write((type));
            this.Write("(ReadOnlySpan<char> value, StringComparison comparisonType, out ");
            this.Write((Model.UnderlyingType));
            this.Write(" result)\n    {\n        if (value.IsEmpty)\n        {\n");

            var binEmptyValue = Model.Values.FirstOrDefault(x => keySelector(x)?.Length == 0);
            if (binEmptyValue != null)
            {
                this.Write("            result = ");
                this.Write((binEmptyValue.MemberValue));
                this.Write(";\n            return true;\n");
            }
            else
            {
                this.Write("            result = 0;\n            return false;\n");
            }

            this.Write("        }\n\n");

            var lookupTable = Model
                .Values.Where(x => keySelector(x)?.Length > 0)
                .ToLookup(x => keySelector(x)![0], CharIgnoreCaseEqualityComparer.Instance);

            this.Write("        switch (value[0])\n        {\n");

            foreach (var curr in lookupTable.OrderBy(x => x.Key))
            {
                if (char.IsSurrogate(curr.Key) || char.IsControl(curr.Key))
                {
                    this.Write("            case '\\u");
                    this.Write((((int)curr.Key).ToString("x4")));
                    this.Write("':\n");
                }
                else if (char.ToUpperInvariant(curr.Key) == curr.Key && char.ToLowerInvariant(curr.Key) == curr.Key)
                {
                    this.Write("            case '");
                    this.Write((curr.Key));
                    this.Write("':\n");
                }
                else
                {
                    this.Write("            case '");
                    this.Write((char.ToUpperInvariant(curr.Key)));
                    this.Write("':\n            case '");
                    this.Write((char.ToLowerInvariant(curr.Key)));
                    this.Write("':\n");
                }

                this.Write("                switch (value)\n                {\n");

                foreach (var enumValue in curr)
                {
                    this.Write("                    case { } when value.Equals(\"");
                    this.Write((keySelector(enumValue)));
                    this.Write("\", comparisonType):\n                        result = ");
                    this.Write((enumValue.MemberValue));
                    this.Write(";\n                        return true;\n");
                }

                this.Write("                }\n                break;\n");
            }

            this.Write("        }\n\n        result = 0;\n        return false;\n    }\n");
        }

        private void WriteDefaultBlock()
        {
            this.Write(
                "    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to\n    /// an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration name or underlying value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <returns>The value represented by the specified name or numeric value. Note that this value need not be a member of the "
            );
            this.Write((Model.Name));
            this.Write(
                " enumeration.</returns>\n    /// <exception cref=\"ArgumentNullException\"><paramref name=\"value\"/> is <see langword=\"null\"/>.</exception>\n    /// <exception cref=\"ArgumentException\"><paramref name=\"value\"/> is empty or does not represent a valid value.</exception>\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                " Parse(string value, bool ignoreCase = false)\n    {\n        if (value is null) ThrowHelper.ThrowArgumentNullException(nameof(value));\n        TryParseName(value.AsSpan(), "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: true, out var result);\n        return (");
            this.Write((Model.RefName));
            this.Write(
                ")result;\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to\n    /// an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration name or underlying value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <returns>The value represented by the specified name or numeric value. Note that this value need not be a member of the "
            );
            this.Write((Model.Name));
            this.Write(
                " enumeration.</returns>\n    /// <exception cref=\"ArgumentException\"><paramref name=\"value\"/> is empty or does not represent a valid value.</exception>\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                " Parse(ReadOnlySpan<char> value, bool ignoreCase = false)\n    {\n        TryParseName(value, "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: true, out var result);\n        return (");
            this.Write((Model.RefName));
            this.Write(
                ")result;\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to\n    /// an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration name or underlying value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <returns>The value represented by the specified name or numeric value or null. Note that this value need not be a member of the "
            );
            this.Write((Model.Name));
            this.Write(
                " enumeration.</returns>\n    /// <exception cref=\"ArgumentException\"><paramref name=\"value\"/> is empty or does not represent a valid value.</exception>\n    [return: NotNullIfNotNull(\"value\")]\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                "? ParseOrNull(string? value, bool ignoreCase = false)\n    {\n        if (value is null) return null;\n        TryParseName(value.AsSpan(), "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: true, out var result);\n        return (");
            this.Write((Model.RefName));
            this.Write(
                ")result;\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to\n    /// an equivalent enumerated object. The return value indicates whether the conversion succeeded.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration name or underlying value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <param name=\"result\">\n    /// When this method returns, result contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value\n    /// if the parse operation succeeds. If the parse operation fails, result contains the default value of the\n    /// underlying type of "
            );
            this.Write((Model.Name));
            this.Write(". Note that this value need not be a member of the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.\n    /// </param>\n    /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n    public static bool TryParse([NotNullWhen(true)] string? value, bool ignoreCase, out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseName(value.AsSpan(), "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: false, out Unsafe.As<");
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to\n    /// an equivalent enumerated object. The return value indicates whether the conversion succeeded.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration name or underlying value to convert.</param>\n    /// <param name=\"result\">\n    /// When this method returns, result contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value\n    /// if the parse operation succeeds. If the parse operation fails, result contains the default value of the\n    /// underlying type of "
            );
            this.Write((Model.Name));
            this.Write(". Note that this value need not be a member of the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.\n    /// </param>\n    /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n    public static bool TryParse([NotNullWhen(true)] string? value, out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseName(value.AsSpan(), "
            );
            this.Write((GetComparisonExpression(false)));
            this.Write(", throwOnFailure: false, out Unsafe.As<");
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to\n    /// an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration name or underlying value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <returns>\n    /// Contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value if the parse operation succeeds.\n    /// If the parse operation fails, result contains <c>null</c> value.\n    /// </returns>\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                "? TryParse(string? value, bool ignoreCase = false)\n    {\n        return TryParseName(value.AsSpan(), "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: false, out var result) ? (");
            this.Write((Model.RefName));
            this.Write(
                "?)result : null;\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to\n    /// an equivalent enumerated object. The return value indicates whether the conversion succeeded.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration name or underlying value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <param name=\"result\">\n    /// When this method returns, result contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value\n    /// if the parse operation succeeds. If the parse operation fails, result contains the default value of the\n    /// underlying type of "
            );
            this.Write((Model.Name));
            this.Write(". Note that this value need not be a member of the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.\n    /// </param>\n    /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n    public static bool TryParse(ReadOnlySpan<char> value, bool ignoreCase, out "
            );
            this.Write((Model.RefName));
            this.Write(" result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseName(value, ");
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: false, out Unsafe.As<");
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to\n    /// an equivalent enumerated object. The return value indicates whether the conversion succeeded.\n    /// </summary>\n    /// <param name=\"value\">The case-sensitive string representation of the enumeration name or underlying value to convert.</param>\n    /// <param name=\"result\">\n    /// When this method returns, result contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value\n    /// if the parse operation succeeds. If the parse operation fails, result contains the default value of the\n    /// underlying type of "
            );
            this.Write((Model.Name));
            this.Write(". Note that this value need not be a member of the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.\n    /// </param>\n    /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n    public static bool TryParse(ReadOnlySpan<char> value, out "
            );
            this.Write((Model.RefName));
            this.Write(" result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseName(value, ");
            this.Write((GetComparisonExpression(false)));
            this.Write(", throwOnFailure: false, out Unsafe.As<");
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to\n    /// an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration name or underlying value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <returns>\n    /// Contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value if the parse operation succeeds.\n    /// If the parse operation fails, result contains <c>null</c> value.\n    /// </returns>\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                "? TryParse(ReadOnlySpan<char> value, bool ignoreCase = false)\n    {\n        return TryParseName(value, "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: false, out var result) ? (");
            this.Write((Model.RefName));
            this.Write("?)result : null;\n    }\n\n");

            WriteTryParse(x => x.MemberName, "Name");

            this.Write(
                "\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to\n    /// an equivalent enumerated object. The return value indicates whether the conversion succeeded.\n    /// </summary>\n    /// <param name=\"name\">The string representation of the enumeration name or underlying value to convert.</param>\n    /// <param name=\"comparisonType\">One of the enumeration values that specifies how the strings will be compared.</param>\n    /// <param name=\"result\">\n    /// When this method returns, result contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value\n    /// if the parse operation succeeds. If the parse operation fails, result contains the default value of the\n    /// underlying type of "
            );
            this.Write((Model.Name));
            this.Write(". Note that this value need not be a member of the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.\n    /// </param>\n    /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n    /// <exception cref=\"ArgumentException\"><paramref name=\"comparisonType\"/> is not a <see cref=\"StringComparison\"/> value.</exception>\n    [Obsolete(\"Use TryParse overload with 'ignoreCase' parameter\")]\n    public static bool TryParse(\n        [NotNullWhen(true)] string? name,\n        StringComparison comparisonType,\n        out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseName(name.AsSpan(), comparisonType, throwOnFailure: false, out Unsafe.As<"
            );
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to\n    /// an equivalent enumerated object. The return value indicates whether the conversion succeeded.\n    /// </summary>\n    /// <param name=\"name\">The case-insensitive string representation of the enumeration name or underlying value to convert.</param>\n    /// <param name=\"result\">\n    /// When this method returns, result contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value\n    /// if the parse operation succeeds. If the parse operation fails, result contains the default value of the\n    /// underlying type of "
            );
            this.Write((Model.Name));
            this.Write(". Note that this value need not be a member of the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.\n    /// </param>\n    /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n    [Obsolete(\"Use TryParse overload with 'ignoreCase' parameter\")]\n    public static bool TryParseIgnoreCase(\n        [NotNullWhen(true)] string? name,\n        out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseName(name.AsSpan(), "
            );
            this.Write((GetComparisonExpression(true)));
            this.Write(", throwOnFailure: false, out Unsafe.As<");
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to\n    /// an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"name\">The case-insensitive string representation of the enumeration name or underlying value to convert.</param>\n    /// <returns>\n    /// Contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value if the parse operation succeeds.\n    /// If the parse operation fails, result contains <c>null</c> value.\n    /// </returns>\n    [Obsolete(\"Use TryParse overload with 'ignoreCase' parameter\")]\n    public static "
            );
            this.Write((Model.RefName));
            this.Write("? TryParseIgnoreCase(string? name)\n    {\n        return TryParseName(name.AsSpan(), ");
            this.Write((GetComparisonExpression(true)));
            this.Write(", throwOnFailure: false, out var result) ? (");
            this.Write((Model.RefName));
            this.Write(
                "?)result : null;\n    }\n\n    /// <summary>\n    /// Converts the string representation of the name or numeric value of one or more enumerated constants to\n    /// an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"name\">The string representation of the enumeration name or underlying value to convert.</param>\n    /// <param name=\"comparisonType\">One of the enumeration values that specifies how the strings will be compared.</param>\n    /// <returns>\n    /// Contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value if the parse operation succeeds.\n    /// If the parse operation fails, result contains <c>null</c> value.\n    /// </returns>\n    /// <exception cref=\"ArgumentException\"><paramref name=\"comparisonType\"/> is not a <see cref=\"StringComparison\"/> value.</exception>\n    [Obsolete(\"Use TryParse overload with 'ignoreCase' parameter\")]\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                "? TryParse(string? name, StringComparison comparisonType)\n    {\n        return TryParseName(name.AsSpan(), comparisonType, throwOnFailure: false, out var result) ? ("
            );
            this.Write((Model.RefName));
            this.Write("?)result : null;\n    }\n");
        }

        private void WriteEnumMemberBlock()
        {
            if (!Model.HasSerializationValue)
                return;

            this.Write(
                "\n    /// <summary>\n    /// Converts the string representation of the serialized value to an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration serialized value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <returns>The value represented by the specified serialized value. Note that this value need not be a member of the "
            );
            this.Write((Model.Name));
            this.Write(
                " enumeration.</returns>\n    /// <exception cref=\"ArgumentNullException\"><paramref name=\"value\"/> is <see langword=\"null\"/>.</exception>\n    /// <exception cref=\"ArgumentException\"><paramref name=\"value\"/> is empty or does not represent a valid value.</exception>\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                " ParseFromEnumMemberValue(string value, bool ignoreCase = false)\n    {\n        if (value is null) ThrowHelper.ThrowArgumentNullException(nameof(value));\n        TryParseEnumMemberValue(value.AsSpan(), "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: true, out var result);\n        return (");
            this.Write((Model.RefName));
            this.Write(
                ")result;\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized value to an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration serialized value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <returns>The value represented by the specified serialized value. Note that this value need not be a member of the "
            );
            this.Write((Model.Name));
            this.Write(
                " enumeration.</returns>\n    /// <exception cref=\"ArgumentException\"><paramref name=\"value\"/> is empty or does not represent a valid value.</exception>\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                " ParseFromEnumMemberValue(ReadOnlySpan<char> value, bool ignoreCase = false)\n    {\n        TryParseEnumMemberValue(value, "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: true, out var result);\n        return (");
            this.Write((Model.RefName));
            this.Write(
                ")result;\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized value to an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration serialized value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <returns>The value represented by the specified serialized value or null. Note that this value need not be a member of the "
            );
            this.Write((Model.Name));
            this.Write(
                " enumeration.</returns>\n    /// <exception cref=\"ArgumentException\"><paramref name=\"value\"/> is empty or does not represent a valid value.</exception>\n    [return: NotNullIfNotNull(\"value\")]\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                "? ParseFromEnumMemberValueOrNull(string? value, bool ignoreCase = false)\n    {\n        if (value is null) return null;\n        TryParseEnumMemberValue(value.AsSpan(), "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: true, out var result);\n        return (");
            this.Write((Model.RefName));
            this.Write(
                ")result;\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized value to an equivalent enumerated object.\n    /// The return value indicates whether the conversion succeeded.\n    /// </summary>\n    /// <param name=\"value\">The value as defined with <see cref=\"System.Runtime.Serialization.EnumMemberAttribute\"/>.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <param name=\"result\">\n    /// When this method returns, result contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by a\n    /// serialized value if the parse operation succeeds. If the parse operation fails, result contains the default\n    /// value of the underlying type of "
            );
            this.Write((Model.Name));
            this.Write(". Note that this value need not be a member of the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.\n    /// </param>\n    /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n    public static bool TryParseFromEnumMemberValue([NotNullWhen(true)] string? value, bool ignoreCase, out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseEnumMemberValue(value.AsSpan(), "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: false, out Unsafe.As<");
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized value to an equivalent enumerated object.\n    /// The return value indicates whether the conversion succeeded.\n    /// </summary>\n    /// <param name=\"value\">The value as defined with <see cref=\"System.Runtime.Serialization.EnumMemberAttribute\"/>.</param>\n    /// <param name=\"result\">\n    /// When this method returns, result contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by a\n    /// serialized value if the parse operation succeeds. If the parse operation fails, result contains the default\n    /// value of the underlying type of "
            );
            this.Write((Model.Name));
            this.Write(". Note that this value need not be a member of the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.\n    /// </param>\n    /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n    public static bool TryParseFromEnumMemberValue([NotNullWhen(true)] string? value, out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseEnumMemberValue(value.AsSpan(), "
            );
            this.Write((GetComparisonExpression(false)));
            this.Write(", throwOnFailure: false, out Unsafe.As<");
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized value to an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The value as defined with <see cref=\"System.Runtime.Serialization.EnumMemberAttribute\"/>.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <returns>\n    /// Contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value if the parse operation succeeds.\n    /// If the parse operation fails, result contains a null value.\n    /// </returns>\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                "? TryParseFromEnumMemberValue(string? value, bool ignoreCase = false)\n    {\n        return TryParseEnumMemberValue(value.AsSpan(), "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: false, out var result) ? (");
            this.Write((Model.RefName));
            this.Write(
                "?)result : null;\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized value to an equivalent enumerated object.\n    /// The return value indicates whether the conversion succeeded.\n    /// </summary>\n    /// <param name=\"value\">The value as defined with <see cref=\"System.Runtime.Serialization.EnumMemberAttribute\"/>.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <param name=\"result\">\n    /// When this method returns, result contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by a\n    /// serialized value if the parse operation succeeds. If the parse operation fails, result contains the default\n    /// value of the underlying type of "
            );
            this.Write((Model.Name));
            this.Write(". Note that this value need not be a member of the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.\n    /// </param>\n    /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n    public static bool TryParseFromEnumMemberValue(ReadOnlySpan<char> value, bool ignoreCase, out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseEnumMemberValue(value, "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: false, out Unsafe.As<");
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized value to an equivalent enumerated object.\n    /// The return value indicates whether the conversion succeeded.\n    /// </summary>\n    /// <param name=\"value\">The value as defined with <see cref=\"System.Runtime.Serialization.EnumMemberAttribute\"/>.</param>\n    /// <param name=\"result\">\n    /// When this method returns, result contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by a\n    /// serialized value if the parse operation succeeds. If the parse operation fails, result contains the default\n    /// value of the underlying type of "
            );
            this.Write((Model.Name));
            this.Write(". Note that this value need not be a member of the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.\n    /// </param>\n    /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n    public static bool TryParseFromEnumMemberValue(ReadOnlySpan<char> value, out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseEnumMemberValue(value, "
            );
            this.Write((GetComparisonExpression(false)));
            this.Write(", throwOnFailure: false, out Unsafe.As<");
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized value to an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The value as defined with <see cref=\"System.Runtime.Serialization.EnumMemberAttribute\"/>.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <returns>\n    /// Contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value if the parse operation succeeds.\n    /// If the parse operation fails, result contains a null value.\n    /// </returns>\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                "? TryParseFromEnumMemberValue(ReadOnlySpan<char> value, bool ignoreCase = false)\n    {\n        return TryParseEnumMemberValue(value, "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: false, out var result) ? (");
            this.Write((Model.RefName));
            this.Write("?)result : null;\n    }\n\n");

            WriteTryParse(x => x.ResolvedSerializedValue, "EnumMemberValue");

            this.Write(
                "\n    /// <summary>\n    /// Converts the string representation of the serialized value to an equivalent enumerated object.\n    /// The return value indicates whether the conversion succeeded.\n    /// </summary>\n    /// <param name=\"value\">The value as defined with <see cref=\"System.Runtime.Serialization.EnumMemberAttribute\"/>.</param>\n    /// <param name=\"comparisonType\">One of the enumeration values that specifies how the strings will be compared.</param>\n    /// <param name=\"result\">\n    /// When this method returns, result contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value\n    /// if the parse operation succeeds. If the parse operation fails, result contains the default value of the\n    /// underlying type of "
            );
            this.Write((Model.Name));
            this.Write(". Note that this value need not be a member of the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.\n    /// </param>\n    /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n    /// <exception cref=\"ArgumentException\"><paramref name=\"comparisonType\"/> is not a <see cref=\"StringComparison\"/> value.</exception>\n    [Obsolete(\"Use TryParseFromEnumMemberValue overload with 'ignoreCase' parameter\")]\n    public static bool TryParseFromEnumMemberValue(\n        [NotNullWhen(true)] string? value,\n        StringComparison comparisonType,\n        out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseEnumMemberValue(value.AsSpan(), comparisonType, throwOnFailure: false, out Unsafe.As<"
            );
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    /// <summary>\n    /// Converts the string representation of the value associated with one enumerated constant to\n    /// an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The value as defined with <see cref=\"System.Runtime.Serialization.EnumMemberAttribute\"/>.</param>\n    /// <param name=\"comparisonType\">One of the enumeration values that specifies how the strings will be compared.</param>\n    /// <returns>\n    /// Contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value if the parse operation succeeds.\n    /// If the parse operation fails, result contains a null value.\n    /// </returns>\n    /// <exception cref=\"ArgumentException\"><paramref name=\"comparisonType\"/> is not a <see cref=\"StringComparison\"/> value.</exception>\n    [Obsolete(\"Use TryParseFromEnumMemberValue overload with 'ignoreCase' parameter\")]\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                "? TryParseFromEnumMemberValue(string? value, StringComparison comparisonType)\n    {\n        return TryParseEnumMemberValue(value.AsSpan(), comparisonType, throwOnFailure: false, out var result) ? ("
            );
            this.Write((Model.RefName));
            this.Write("?)result : null;\n    }\n");
        }

        private void WriteDescriptionBlock()
        {
            if (!Model.HasDescription)
                return;

            this.Write("\n    public static ");
            this.Write((Model.RefName));
            this.Write(
                " CreateFromDescription(string description, StringComparison comparisonType = StringComparison.Ordinal)\n    {\n        if (description is null) ThrowHelper.ThrowArgumentNullException(nameof(description));\n        TryParseDescription(description.AsSpan(), comparisonType, throwOnFailure: true, out var result);\n        return ("
            );
            this.Write((Model.RefName));
            this.Write(")result;\n    }\n\n    public static ");
            this.Write((Model.RefName));
            this.Write(
                " CreateFromDescription(ReadOnlySpan<char> description, StringComparison comparisonType = StringComparison.Ordinal)\n    {\n        TryParseDescription(description, comparisonType, throwOnFailure: true, out var result);\n        return ("
            );
            this.Write((Model.RefName));
            this.Write(")result;\n    }\n\n    [return: NotNullIfNotNull(\"description\")]\n    public static ");
            this.Write((Model.RefName));
            this.Write(
                "? CreateFromDescriptionOrNull(string? description, StringComparison comparisonType = StringComparison.Ordinal)\n    {\n        if (description is null) return null;\n        TryParseDescription(description.AsSpan(), comparisonType, throwOnFailure: true, out var result);\n        return ("
            );
            this.Write((Model.RefName));
            this.Write(
                ")result;\n    }\n\n    public static bool TryCreateFromDescription([NotNullWhen(true)] string? description, StringComparison comparisonType, out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseDescription(description.AsSpan(), comparisonType, throwOnFailure: false, out Unsafe.As<"
            );
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    public static bool TryCreateFromDescription([NotNullWhen(true)] string? description, out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseDescription(description.AsSpan(), StringComparison.Ordinal, throwOnFailure: false, out Unsafe.As<"
            );
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(">(ref result));\n    }\n\n    public static ");
            this.Write((Model.RefName));
            this.Write(
                "? TryCreateFromDescription(string? description, StringComparison comparisonType = StringComparison.Ordinal)\n    {\n        return TryParseDescription(description.AsSpan(), comparisonType, throwOnFailure: false, out var result) ? ("
            );
            this.Write((Model.RefName));
            this.Write(
                "?)result : null;\n    }\n\n    public static bool TryCreateFromDescription(ReadOnlySpan<char> description, StringComparison comparisonType, out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseDescription(description, comparisonType, throwOnFailure: false, out Unsafe.As<"
            );
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    public static bool TryCreateFromDescription(ReadOnlySpan<char> description, out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseDescription(description, StringComparison.Ordinal, throwOnFailure: false, out Unsafe.As<"
            );
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(">(ref result));\n    }\n\n    public static ");
            this.Write((Model.RefName));
            this.Write(
                "? TryCreateFromDescription(ReadOnlySpan<char> description, StringComparison comparisonType = StringComparison.Ordinal)\n    {\n        return TryParseDescription(description, comparisonType, throwOnFailure: false, out var result) ? ("
            );
            this.Write((Model.RefName));
            this.Write("?)result : null;\n    }\n\n");

            WriteTryParse(x => x.Description, "Description", "description", allowNumbers: false);
        }

        private void WriteDisplayBlock()
        {
            if (Model.HasDisplayName)
            {
                this.Write(
                    "\n    public static bool TryCreateFromDisplayShortName(\n        [NotNullWhen(true)] string? displayShortName,\n        StringComparison comparisonType,\n        out "
                );
                this.Write((Model.RefName));
                this.Write(" result)\n    {\n");

                if (Model.Values.All(x => x.Display?.ShortName == null))
                {
                    this.Write(
                        "        return TryCreateFromDisplayName(displayShortName, comparisonType, out result);\n"
                    );
                }
                else
                {
                    this.Write("        ");
                    this.Write((Model.UnderlyingType));
                    this.Write(" numValue;\n        switch (displayShortName)\n        {\n");

                    foreach (var curr in Model.Values.Where(x => x.Display?.ShortName != null))
                    {
                        this.Write("            case { } s when s.Equals(");
                        this.Write(
                            (
                                curr.Display!.ResourceShortName != null
                                    ? Append(curr.Display.ResourceShortName)
                                    : Append($"\"{curr.Display.ShortName}\"")
                            )
                        );

                        this.Write(", comparisonType):\n                numValue = ");
                        this.Write((curr.MemberValue));
                        this.Write(";\n                break;\n");
                    }

                    this.Write(
                        "            default:\n                return TryCreateFromDisplayName(displayShortName, comparisonType, out result);\n        }\n\n        result = ("
                    );
                    this.Write((Model.RefName));
                    this.Write(")numValue;\n        return true;\n");
                }

                this.Write(
                    "    }\n\n    public static bool TryCreateFromDisplayShortName([NotNullWhen(true)] string? displayShortName, out "
                );
                this.Write((Model.RefName));
                this.Write(
                    " result)\n    {\n        return TryCreateFromDisplayShortName(displayShortName, StringComparison.Ordinal, out result);\n    }\n\n    public static "
                );
                this.Write((Model.RefName));
                this.Write(
                    "? TryCreateFromDisplayShortName(string? displayShortName, StringComparison comparisonType)\n    {\n        return TryCreateFromDisplayShortName(displayShortName, comparisonType, out "
                );
                this.Write((Model.RefName));
                this.Write(" result) ? result : null;\n    }\n\n    public static ");
                this.Write((Model.RefName));
                this.Write(
                    "? TryCreateFromDisplayShortName(string? displayShortName)\n    {\n        return TryCreateFromDisplayShortName(displayShortName, StringComparison.Ordinal, out "
                );
                this.Write((Model.RefName));
                this.Write(
                    " result) ? result : null;\n    }\n\n    public static bool TryCreateFromDisplayName(\n        [NotNullWhen(true)] string? displayName,\n        StringComparison comparisonType,\n        out "
                );
                this.Write((Model.RefName));
                this.Write(" result)\n    {\n");

                if (Model.Values.AsSpan().Length == 0)
                {
                    this.Write("        result = default;\n        return false;\n");
                }
                else
                {
                    this.Write("        ");
                    this.Write((Model.UnderlyingType));
                    this.Write(" numValue;\n        switch (displayName)\n        {\n");

                    foreach (var curr in Model.Values)
                    {
                        this.Write("            case { } s when s.Equals(");
                        this.Write(
                            (
                                curr.Display?.ResourceName != null ? Append(curr.Display.ResourceName)
                                : curr.Display?.Name != null ? Append($"\"{curr.Display.Name}\"")
                                : Append($"\"{curr.MemberName}\"")
                            )
                        );

                        this.Write(", comparisonType):\n                numValue = ");
                        this.Write((curr.MemberValue));
                        this.Write(";\n                break;\n");
                    }

                    this.Write(
                        "            default:\n                result = default;\n                return false;\n        }\n\n        result = ("
                    );
                    this.Write((Model.RefName));
                    this.Write(")numValue;\n        return true;\n");
                }

                this.Write(
                    "    }\n\n    public static bool TryCreateFromDisplayName([NotNullWhen(true)] string? displayName, out "
                );
                this.Write((Model.RefName));
                this.Write(
                    " result)\n    {\n        return TryCreateFromDisplayName(displayName, StringComparison.Ordinal, out result);\n    }\n\n    public static "
                );
                this.Write((Model.RefName));
                this.Write(
                    "? TryCreateFromDisplayName(string? displayName, StringComparison comparisonType)\n    {\n        return TryCreateFromDisplayName(displayName, comparisonType, out "
                );
                this.Write((Model.RefName));
                this.Write(" result) ? result : null;\n    }\n\n    public static ");
                this.Write((Model.RefName));
                this.Write(
                    "? TryCreateFromDisplayName(string? displayName)\n    {\n        return TryCreateFromDisplayName(displayName, StringComparison.Ordinal, out "
                );
                this.Write((Model.RefName));
                this.Write(" result) ? result : null;\n    }\n");
            }

            if (Model.HasDisplayDescription)
            {
                this.Write(
                    "\n    public static bool TryCreateFromDescription(\n        [NotNullWhen(true)] string? description,\n        StringComparison comparisonType,\n        out "
                );
                this.Write((Model.RefName));
                this.Write(" result)\n    {\n");

                if (Model.Values.All(x => x.Display?.Description == null))
                {
                    this.Write("        result = default;\n        return false;\n");
                }
                else
                {
                    this.Write("        ");
                    this.Write((Model.UnderlyingType));
                    this.Write(" numValue;\n        switch (description)\n        {\n");

                    foreach (var curr in Model.Values.Where(x => x.Display?.Description != null))
                    {
                        this.Write("            case { } s when s.Equals(");
                        this.Write(
                            (
                                curr.Display!.ResourceDescription != null
                                    ? Append(curr.Display.ResourceDescription)
                                    : Append($"\"{curr.Display.Description}\"")
                            )
                        );

                        this.Write(", comparisonType):\n                numValue = ");
                        this.Write((curr.MemberValue));
                        this.Write(";\n                break;\n");
                    }

                    this.Write(
                        "            default:\n                result = default;\n                return false;\n        }\n\n        result = ("
                    );
                    this.Write((Model.RefName));
                    this.Write(")numValue;\n        return true;\n");
                }

                this.Write(
                    "    }\n\n    public static bool TryCreateFromDescription([NotNullWhen(true)] string? description, out "
                );
                this.Write((Model.RefName));
                this.Write(
                    " result)\n    {\n        return TryCreateFromDescription(description, StringComparison.Ordinal, out result);\n    }\n\n    public static "
                );
                this.Write((Model.RefName));
                this.Write(
                    "? TryCreateFromDescription(string? description, StringComparison comparisonType)\n    {\n        return TryCreateFromDescription(description, comparisonType, out "
                );
                this.Write((Model.RefName));
                this.Write(" result) ? result : null;\n    }\n\n    public static ");
                this.Write((Model.RefName));
                this.Write(
                    "? TryCreateFromDescription(string? description)\n    {\n        return TryCreateFromDescription(description, StringComparison.Ordinal, out "
                );
                this.Write((Model.RefName));
                this.Write(" result) ? result : null;\n    }\n");
            }
        }

        public void WriteJsonBlock()
        {
            if (!Model.HasJsonProperty && (Model.SelectedGenerators & SelectedGenerators.JsonConverter) == 0)
                return;

            this.Write(
                "\n    /// <summary>\n    /// Converts the string representation of the serialized JSON value to an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration serialized JSON value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <returns>The value represented by the specified serialized value. Note that this value need not be a member of the "
            );
            this.Write((Model.Name));
            this.Write(
                " enumeration.</returns>\n    /// <exception cref=\"ArgumentNullException\"><paramref name=\"value\"/> is <see langword=\"null\"/>.</exception>\n    /// <exception cref=\"ArgumentException\"><paramref name=\"value\"/> is empty or does not represent a valid value.</exception>\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                " ParseJsonString(string value, bool ignoreCase = false)\n    {\n        if (value is null) ThrowHelper.ThrowArgumentNullException(nameof(value));\n        TryParseJsonString(value.AsSpan(), "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: true, out var result);\n        return (");
            this.Write((Model.RefName));
            this.Write(
                ")result;\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized JSON value to an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration serialized JSON value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <returns>The value represented by the specified serialized value. Note that this value need not be a member of the "
            );
            this.Write((Model.Name));
            this.Write(
                " enumeration.</returns>\n    /// <exception cref=\"ArgumentException\"><paramref name=\"value\"/> is empty or does not represent a valid value.</exception>\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                " ParseJsonString(ReadOnlySpan<char> value, bool ignoreCase = false)\n    {\n        TryParseJsonString(value, "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: true, out var result);\n        return (");
            this.Write((Model.RefName));
            this.Write(
                ")result;\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized JSON value to an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration serialized JSON value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <returns>The value represented by the specified serialized value or null. Note that this value need not be a member of the "
            );
            this.Write((Model.Name));
            this.Write(
                " enumeration.</returns>\n    /// <exception cref=\"ArgumentException\"><paramref name=\"value\"/> is empty or does not represent a valid value.</exception>\n    [return: NotNullIfNotNull(\"value\")]\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                "? ParseJsonStringOrNull(string? value, bool ignoreCase = false)\n    {\n        if (value is null) return null;\n        TryParseJsonString(value.AsSpan(), "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: true, out var result);\n        return (");
            this.Write((Model.RefName));
            this.Write(
                ")result;\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized JSON value to an equivalent enumerated object.\n    /// The return value indicates whether the conversion succeeded.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration serialized JSON value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <param name=\"result\">\n    /// When this method returns, result contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by a\n    /// serialized JSON value if the parse operation succeeds. If the parse operation fails, result contains the default\n    /// value of the underlying type of "
            );
            this.Write((Model.Name));
            this.Write(". Note that this value need not be a member of the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.\n    /// </param>\n    /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n    public static bool TryParseJsonString([NotNullWhen(true)] string? value, bool ignoreCase, out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseJsonString(value.AsSpan(), "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: false, out Unsafe.As<");
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized JSON value to an equivalent enumerated object.\n    /// The return value indicates whether the conversion succeeded.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration serialized JSON value to convert.</param>\n    /// <param name=\"result\">\n    /// When this method returns, result contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by a\n    /// serialized JSON value if the parse operation succeeds. If the parse operation fails, result contains the default\n    /// value of the underlying type of "
            );
            this.Write((Model.Name));
            this.Write(". Note that this value need not be a member of the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.\n    /// </param>\n    /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n    public static bool TryParseJsonString([NotNullWhen(true)] string? value, out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseJsonString(value.AsSpan(), "
            );
            this.Write((GetComparisonExpression(false)));
            this.Write(", throwOnFailure: false, out Unsafe.As<");
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized JSON value to an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration serialized JSON value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <returns>\n    /// Contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value if the parse operation succeeds.\n    /// If the parse operation fails, result contains a null value.\n    /// </returns>\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                "? TryParseJsonString(string? value, bool ignoreCase = false)\n    {\n        return TryParseJsonString(value.AsSpan(), "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: false, out var result) ? (");
            this.Write((Model.RefName));
            this.Write(
                "?)result : null;\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized JSON value to an equivalent enumerated object.\n    /// The return value indicates whether the conversion succeeded.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration serialized JSON value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <param name=\"result\">\n    /// When this method returns, result contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by a\n    /// serialized JSON value if the parse operation succeeds. If the parse operation fails, result contains the default\n    /// value of the underlying type of "
            );
            this.Write((Model.Name));
            this.Write(". Note that this value need not be a member of the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.\n    /// </param>\n    /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n    public static bool TryParseJsonString(ReadOnlySpan<char> value, bool ignoreCase, out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseJsonString(value, "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: false, out Unsafe.As<");
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized JSON value to an equivalent enumerated object.\n    /// The return value indicates whether the conversion succeeded.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration serialized JSON value to convert.</param>\n    /// <param name=\"result\">\n    /// When this method returns, result contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by a\n    /// serialized JSON value if the parse operation succeeds. If the parse operation fails, result contains the default\n    /// value of the underlying type of "
            );
            this.Write((Model.Name));
            this.Write(". Note that this value need not be a member of the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.\n    /// </param>\n    /// <returns><c>true</c> if the value parameter was converted successfully; otherwise, <c>false</c>.</returns>\n    public static bool TryParseJsonString(ReadOnlySpan<char> value, out "
            );
            this.Write((Model.RefName));
            this.Write(
                " result)\n    {\n        Unsafe.SkipInit(out result);\n        return TryParseJsonString(value, "
            );
            this.Write((GetComparisonExpression(false)));
            this.Write(", throwOnFailure: false, out Unsafe.As<");
            this.Write((Model.RefName));
            this.Write(", ");
            this.Write((Model.UnderlyingType));
            this.Write(
                ">(ref result));\n    }\n\n    /// <summary>\n    /// Converts the string representation of the serialized JSON value to an equivalent enumerated object.\n    /// </summary>\n    /// <param name=\"value\">The string representation of the enumeration serialized JSON value to convert.</param>\n    /// <param name=\"ignoreCase\"><see langword=\"true\"/> to ignore case; <see langword=\"false\"/> to regard case.</param>\n    /// <returns>\n    /// Contains an object of type "
            );
            this.Write((Model.Name));
            this.Write(
                " whose value is represented by value if the parse operation succeeds.\n    /// If the parse operation fails, result contains a null value.\n    /// </returns>\n    public static "
            );
            this.Write((Model.RefName));
            this.Write(
                "? TryParseJsonString(ReadOnlySpan<char> value, bool ignoreCase = false)\n    {\n        return TryParseJsonString(value, "
            );
            this.Write((GetIgnoreCaseToComparisonExpression()));
            this.Write(", throwOnFailure: false, out var result) ? (");
            this.Write((Model.RefName));
            this.Write("?)result : null;\n    }\n\n");

            WriteTryParse(x => x.ResolvedJsonValue, "JsonString", allowNumbers: false);
        }

        private void WriteMiscellaneousBlock()
        {
            this.Write("\n    /// <summary>Retrieves an array of the values of the constants in the ");
            this.Write((Model.Name));
            this.Write(
                " enumeration.</summary>\n    /// <returns>An array that contains the values of the constants in "
            );
            this.Write((Model.Name));
            this.Write(".</returns>\n    public static ");
            this.Write((Model.RefName));
            this.Write("[] GetValues()\n    {\n        return new[]\n        {\n");

            foreach (var curr in Model.UniqueValues)
            {
                this.Write("            (");
                this.Write((Model.RefName));
                this.Write(")(");
                this.Write((curr.MemberValue));
                this.Write("),\n");
            }

            this.Write("        };\n    }\n\n    /// <summary>Retrieves an array of the names of the constants in ");
            this.Write((Model.Name));
            this.Write(" enumeration.</summary>\n    /// <returns>A string array of the names of the constants in ");
            this.Write((Model.Name));
            this.Write(".</returns>\n    public static string[] GetNames()\n    {\n        return new[]\n        {\n");

            foreach (var curr in Model.Values)
            {
                this.Write("            \"");
                this.Write((curr.MemberName));
                this.Write("\",\n");
            }

            this.Write("        };\n    }\n");
        }

        public EnumFactoryWriter(StringBuilder builder)
            : base(builder) { }

        public override string GetFileName() => CodeWriterHelper.GetFileName(Model, "Factory");

        protected override bool CanGenerateFor(EnumToGenerate model) =>
            (model.SelectedGenerators & (SelectedGenerators.MainGenerator | SelectedGenerators.JsonConverter)) != 0;
    }
}
