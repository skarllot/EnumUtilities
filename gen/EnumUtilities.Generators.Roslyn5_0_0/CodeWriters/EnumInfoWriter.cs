// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     Runtime Version: 16.0.0.0
//  
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------
namespace Raiqub.Generators.EnumUtilities.CodeWriters
{
    using System;
    using System.Text;
    using Common;
    using Models;
    using T4CodeWriter;

    /// <summary>
    /// Class to produce the template output
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Microsoft.VisualStudio.TextTemplating", "16.0.0.0")]
    public partial class EnumInfoWriter : CodeWriterBase<EnumToGenerate>
    {
        /// <summary>
        /// Create the template output
        /// </summary>
        public override string TransformText()
        {
            this.Write(
                "\n// <auto-generated />\n#nullable enable\n\nusing System;\nusing System.Runtime.CompilerServices;\nusing Raiqub.Generators.EnumUtilities.Formatters;\nusing Raiqub.Generators.EnumUtilities.Parsers;\n\n#pragma warning disable CS1591 // publicly visible type or member must be documented\n\n"
            );

            if (!string.IsNullOrEmpty(Model.Namespace))
            {
                Write($"namespace {Model.Namespace};\n\n");
            }

            this.Write("/// <summary>Provides metadata for <see cref=\"");
            this.Write((Model.Name));
            this.Write(
                "\" /> enumeration.</summary>\n[global::System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverage]\n[global::System.CodeDom.Compiler.GeneratedCodeAttribute(\""
            );
            this.Write((CurrentAssemblyName.Name));
            this.Write("\", \"");
            this.Write((Append($"{CurrentAssemblyName.Version}")));
            this.Write("\")]\n");
            this.Write((Model.IsPublic ? "public" : "internal"));
            this.Write(" static partial class ");
            this.Write((Model.MetadataClassName));
            this.Write(
                "\n{\n    /// <inheritdoc cref=\"Raiqub.Generators.EnumUtilities.Contracts.IEnumMetadata.MinimumValue\" />\n    public const "
            );
            this.Write((Model.UnderlyingType));
            this.Write(" MinimumValue = ");
            this.Write((Model.OrderedValues.First().MemberValue));
            this.Write(
                ";\n\n    /// <inheritdoc cref=\"Raiqub.Generators.EnumUtilities.Contracts.IEnumMetadata.MaximumValue\" />\n    public const "
            );
            this.Write((Model.UnderlyingType));
            this.Write(" MaximumValue = ");
            this.Write((Model.OrderedValues.Last().MemberValue));
            this.Write(
                ";\n\n    /// <inheritdoc cref=\"Raiqub.Generators.EnumUtilities.Contracts.IEnumMetadata.ValueCount\" />\n    public const int ValueCount = "
            );
            this.Write((Model.UniqueValues.Count));
            this.Write(";\n\n");

            WriteDefaultBlock();

            this.Write("}\n");
            return this.GenerationEnvironment.ToString();
        }

        private void WriteNames(
            string className,
            string xmlDocAllRef,
            string xmlDocItemRef,
            string xmlDocAction,
            Func<EnumValue, string> keySelector
        )
        {
            this.Write("    /// <summary>Provides constant values for <see cref=\"");
            this.Write((Model.Name));
            this.Write("\" /> ");
            this.Write((xmlDocAllRef));
            this.Write(".</summary>\n    public static partial class ");
            this.Write((className));
            this.Write(
                "\n    {\n        /// <summary>Represents the largest possible number of characters produced by "
            );
            this.Write((xmlDocAction));
            this.Write(" a <see cref=\"");
            this.Write((Model.Name));
            this.Write(
                "\" /> value to string, based on defined members.</summary>\n        public const int MaxCharsLength = "
            );
            this.Write((Model.Values.Max(x => keySelector(x).Length)));
            this.Write(";\n");

            foreach (var curr in Model.Values)
            {
                this.Write("\n        /// <summary>The string representation of <see cref=\"");
                this.Write((Model.Name));
                this.Write(".");
                this.Write((curr.MemberName));
                this.Write("\" /> ");
                this.Write((xmlDocItemRef));
                this.Write(".</summary>\n        public const string ");
                this.Write((curr.MemberName));
                this.Write(" = \"");
                this.Write((keySelector(curr)));
                this.Write("\";\n");
            }

            this.Write("    }\n\n    /// <summary>Provides static values for <see cref=\"");
            this.Write((Model.Name));
            this.Write("\" /> UTF-8 encoded ");
            this.Write((xmlDocAllRef));
            this.Write(".</summary>\n    public static partial class Utf8");
            this.Write((className));
            this.Write("\n    {\n        /// <summary>Represents the largest possible number of bytes produced by ");
            this.Write((xmlDocAction));
            this.Write(" a <see cref=\"");
            this.Write((Model.Name));
            this.Write(
                "\" /> value to UTF-8 string, based on defined members.</summary>\n        public const int MaxBytesLength = "
            );
            this.Write((Model.Values.Max(x => _utf8Encoding.GetByteCount(keySelector(x)))));
            this.Write(";\n");

            foreach (var curr in Model.Values)
            {
                this.Write("\n        /// <summary>The UTF-8 representation of <see cref=\"");
                this.Write((Model.Name));
                this.Write(".");
                this.Write((curr.MemberName));
                this.Write("\" /> ");
                this.Write((xmlDocItemRef));
                this.Write(".</summary>\n        public static ReadOnlySpan<byte> ");
                this.Write((curr.MemberName));
                this.Write(" => new byte[");
                this.Write((_utf8Encoding.GetByteCount(keySelector(curr))));
                this.Write("] { ");
                this.Write((_utf8Encoding.GetBytes(keySelector(curr)).JoinToString()));
                this.Write(" };\n");
            }

            this.Write("    }\n");
        }

        private static readonly Encoding _utf8Encoding = Encoding.UTF8;

        private void WriteDefaultBlock()
        {
            if (HasMainGenerator)
            {
                WriteNames("Name", "members names", "name", "converting", x => x.MemberName);
            }

            if (HasMainGenerator && Model.HasSerializationValue)
            {
                Write('\n');
                WriteNames(
                    "SerializedValue",
                    "serialized members values",
                    "serialized value",
                    "serializing",
                    x => x.ResolvedSerializedValue
                );
            }

            if (HasMainGenerator && Model.HasJsonProperty)
            {
                Write('\n');
                WriteNames(
                    "JsonValue",
                    "serialized members values",
                    "serialized value",
                    "serializing",
                    x => x.ResolvedJsonValue
                );
            }
        }

        public EnumInfoWriter(StringBuilder builder)
            : base(builder) { }

        private bool HasMainGenerator =>
            (Model.SelectedGenerators & SelectedGenerators.MainGenerator) == SelectedGenerators.MainGenerator;

        public override string GetFileName() => CodeWriterHelper.GetFileName(Model, "EnumInfo");

        protected override bool CanGenerateFor(EnumToGenerate model) =>
            (model.SelectedGenerators & SelectedGenerators.MainGenerator) != 0;
    }
}
